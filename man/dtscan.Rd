% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dtscan.R
\name{dtscan}
\alias{dtscan}
\title{Triangle-Based dtscan Clustering}
\usage{
dtscan(x, min_pts = 5, max_closeness, parallel = TRUE)
}
\arguments{
\item{x}{Numeric matrix (n × 2) or two‑column data.frame of coordinates (x, y).}

\item{min_pts}{Integer; minimum number of neighbors for a point to be considered a core point.
Defaults to \code{5L}.}

\item{max_closeness}{Numeric; maximum edge length for two points to be considered connected.}

\item{parallel}{Logical; whether to preprocess the triangulation in parallel.
Defaults to \code{TRUE}.}
}
\value{
Integer vector of length \code{nrow(x)}, giving 1‑based cluster IDs. Points not
assigned to any cluster are \code{NA}-s.
}
\description{
Perform density-based clustering on a 2D point set via a triangle‑based algorithm
implemented in Rust for high performance. A Delaunay triangulation is computed,
edges are extracted and sorted by length, and clusters grow by traversing short edges
from core points.
}
\note{
\itemize{
\item Duplicate or collinear points can produce degenerate triangles; ensure \code{x} has unique,
non‑collinear coordinates.
\item Preprocessing in parallel (done internally by Rust) can speed up large point sets
but may incur overhead on small data;
\item Unlike standard dtscan, dtscan uses the Delaunay graph for neighborhood definition, so
cluster boundaries may differ from other implementations.
}
}
\examples{
data("penguins")
xy = penguins[, c('bill_len', 'bill_dep')] |> na.omit()
xy$clust_id = dtscan(xy, max_closeness = 0.85)
xy$col <- ifelse(is.na(xy$clust_id), "lightgrey", 
 hcl.colors(length(u <- sort(unique(na.omit(xy$clust_id)))))[match(xy$clust_id, u)])
plot(xy[, c(1,2)], col = xy$col, pch = 19)

}
\references{
Kim, S. & Cho, Y. (2019). Triangle-based density clustering using Delaunay triangulation.
Sensors, 19(18), 3926.
\url{https://pmc.ncbi.nlm.nih.gov/articles/PMC6767241/}

Ported from \url{https://github.com/randogoth/xenobalanus}
}
